#
# gcov kernel patch (2004-08-12)
#   Provides GCOV code coverage infrastructure for Linux kernel 2.4.
#   See http://ltp.sourceforge.net/coverage/gcov-kernel.php for details.
#
# Documentation/Configure.help |   30 
# Makefile                     |   16 
# arch/i386/config.in          |    3 
# arch/i386/kernel/head.S      |   23 
# arch/ia64/config.in          |    3 
# arch/ia64/kernel/head.S      |   21 
# arch/ppc/boot/chrp/main.c    |   10 
# arch/ppc/config.in           |    2 
# arch/ppc/kernel/entry.S      |    9 
# arch/ppc/kernel/head.S       |   22 
# arch/ppc/kernel/prom_init.c  |    4 
# arch/ppc64/config.in         |    2 
# arch/ppc64/kernel/head.S     |   21 
# arch/s390/config.in          |    3 
# arch/s390/kernel/head.S      |   20 
# arch/s390x/config.in         |    3 
# arch/s390x/kernel/head.S     |   20 
# arch/x86_64/config.in        |    2 
# arch/x86_64/kernel/head.S    |   21 
# drivers/Makefile             |    4 
# drivers/gcov/Config.in       |   13 
# drivers/gcov/Makefile        |   15 
# drivers/gcov/gcov-core.c     |  246 ++++++
# drivers/gcov/gcov-proc.c     | 1596 +++++++++++++++++++++++++++++++++++++++++
# include/linux/gcov.h         |  184 ++++
# include/linux/module.h       |    2 
# kernel/module.c              |   20 
# 27 files changed, 2310 insertions(+), 5 deletions(-)
#

diff -Naurp linux-2.4/Documentation/Configure.help linux-2.4-gcov/Documentation/Configure.help
--- linux-2.4/Documentation/Configure.help	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4-gcov/Documentation/Configure.help	2004-08-12 17:07:16.470312116 +0200
@@ -25374,6 +25374,36 @@ CONFIG_PROCESS_DEBUG
   a debugging option; you probably do not want to set it unless you
   are an S390 port maintainer.
 
+Include GCOV coverage profiling
+CONFIG_GCOV_PROFILE
+  Provide infrastructure for GCOV kernel coverage support.
+
+  Enable GCOV_ALL to get coverage data for the entire kernel
+  source.
+
+  To get coverage data for only specific files or directories,
+  add the following line to the respective Makefile:
+
+          EXTRA_CFLAGS += $(GCOV_FLAGS)
+
+  Note that GCOV_PROC has to be enabled to access GCOV kernel
+  coverage data.
+
+Profile entire Kernel
+CONFIG_GCOV_ALL
+  If you say Y here, it will compile the entire kernel with coverage
+  option enabled.
+
+Provide GCOV proc file system entry
+CONFIG_GCOV_PROC
+  Install a proc file system entry at /proc/gcov which provides
+  access to the current coverage state of the kernel code.
+
+  This option is also available as a module called gcov-proc.o.
+  It can be loaded using:
+
+    modprobe gcov-proc
+
 #
 # ARM options
 #
diff -Naurp linux-2.4/Makefile linux-2.4-gcov/Makefile
--- linux-2.4/Makefile	2004-02-18 14:36:32.000000000 +0100
+++ linux-2.4-gcov/Makefile	2004-08-12 17:07:16.480312116 +0200
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 4
 SUBLEVEL = 35
-EXTRAVERSION =
+EXTRAVERSION = -gcov
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
@@ -19,6 +19,7 @@ FINDHPATH	= $(HPATH)/asm $(HPATH)/linux 
 HOSTCC  	= gcc
 HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
 
+GCOV_FLAGS	= -fprofile-arcs -ftest-coverage
 ifndef CROSS_COMPILE
 CROSS_COMPILE 	= /vobs/cots/eldk/eldk2.1/usr/bin/ppc_82xx-
 endif
 #
@@ -194,6 +195,7 @@ DRIVERS-$(CONFIG_BLUEZ) += drivers/bluet
 DRIVERS-$(CONFIG_HOTPLUG_PCI) += drivers/hotplug/vmlinux-obj.o
 DRIVERS-$(CONFIG_ISDN_BOOL) += drivers/isdn/vmlinux-obj.o
 DRIVERS-$(CONFIG_CRYPTO) += crypto/crypto.o
+DRIVERS-$(CONFIG_GCOV_PROFILE) += drivers/gcov/gcov.o
 
 DRIVERS := $(DRIVERS-y)
 
@@ -323,7 +325,11 @@ include/config/MARKER: scripts/split-inc
 linuxsubdirs: $(patsubst %, _dir_%, $(SUBDIRS))
 
 $(patsubst %, _dir_%, $(SUBDIRS)) : dummy include/linux/version.h include/config/MARKER
+ifdef CONFIG_GCOV_ALL
+	$(MAKE) CFLAGS="$(CFLAGS) $(GCOV_FLAGS) $(CFLAGS_KERNEL)" -C $(patsubst _dir_%, %, $@)
+else
 	$(MAKE) CFLAGS="$(CFLAGS) $(CFLAGS_KERNEL)" -C $(patsubst _dir_%, %, $@)
+endif
 
 $(TOPDIR)/include/linux/version.h: include/linux/version.h
 $(TOPDIR)/include/linux/compile.h: include/linux/compile.h
@@ -396,7 +402,11 @@ modules: $(patsubst %, _mod_%, $(SUBDIRS
 
 .PHONY: $(patsubst %, _mod_%, $(SUBDIRS))
 $(patsubst %, _mod_%, $(SUBDIRS)) : include/linux/version.h include/config/MARKER
+ifdef CONFIG_GCOV_ALL
+	$(MAKE) -C $(patsubst _mod_%, %, $@) CFLAGS="$(CFLAGS) $(GCOV_FLAGS) $(MODFLAGS)" MAKING_MODULES=1 modules
+else
 	$(MAKE) -C $(patsubst _mod_%, %, $@) CFLAGS="$(CFLAGS) $(MODFLAGS)" MAKING_MODULES=1 modules
+endif
 
 .PHONY: modules_install
 modules_install: _modinst_ $(patsubst %, _modinst_%, $(SUBDIRS)) _modinst_post
@@ -448,7 +458,7 @@ modules modules_install: dummy
 endif
 
 clean:	archclean
-	find . \( -name '*.[oas]' -o -name core -o -name '.*.flags' \) -type f -print \
+	find . \( -name '*.[oas]' -o -name core -o -name '.*.flags' -o -name '*.bb' -o -name '*.bbg' -o -name '*.gcno' \) -type f -print \
 		| grep -v lxdialog/ | xargs rm -f
 	rm -f $(CLEAN_FILES)
 	rm -rf $(CLEAN_DIRS)
@@ -464,7 +474,7 @@ distclean: mrproper
 	rm -f core `find . \( -not -type d \) -and \
 		\( -name '*.orig' -o -name '*.rej' -o -name '*~' \
 		-o -name '*.bak' -o -name '#*#' -o -name '.*.orig' \
-		-o -name '.*.rej' -o -name '.SUMS' -o -size 0 \) -type f -print` TAGS tags
+		-o -name '.*.rej' -o -name '.SUMS' -o -name '*.bb' -o -name '*.bbg' -o -name '*.gcno' -o -size 0 \) -type f -print` TAGS tags
 
 backup: mrproper
 	cd .. && tar cf - linux/ | gzip -9 > backup.gz
diff -Naurp linux-2.4/arch/i386/config.in linux-2.4-gcov/arch/i386/config.in
--- linux-2.4/arch/i386/config.in	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4-gcov/arch/i386/config.in	2004-08-12 17:07:15.810312116 +0200
@@ -486,4 +486,7 @@ int 'Kernel messages buffer length shift
 endmenu
 
 source crypto/Config.in
+
+source drivers/gcov/Config.in
+
 source lib/Config.in
diff -Naurp linux-2.4/arch/i386/kernel/head.S linux-2.4-gcov/arch/i386/kernel/head.S
--- linux-2.4/arch/i386/kernel/head.S	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4-gcov/arch/i386/kernel/head.S	2004-08-12 17:07:15.820312116 +0200
@@ -446,3 +446,26 @@ ENTRY(gdt_table)
 	.quad 0x00009a0000000000	/* 0x50 APM CS 16 code (16 bit) */
 	.quad 0x0040920000000000	/* 0x58 APM DS    data */
 	.fill NR_CPUS*4,8,0		/* space for TSS's and LDT's */
+
+ 
+ #ifdef CONFIG_GCOV_PROFILE
+ /*
+  * The .ctors-section contains a list of pointers to constructor
+  * functions which are used to initialize gcov structures.
+  *
+  * Because there is no NULL at the end of the constructor list
+  * in the kernel we need the addresses of both the constructor
+  * as well as the destructor list which are supposed to be
+  * adjacent.
+  */
+ 
+ .section ".ctors","aw"
+ .globl  __CTOR_LIST__
+ .type   __CTOR_LIST__,@object
+ __CTOR_LIST__:
+ .section ".dtors","aw"
+ .globl  __DTOR_LIST__
+ .type   __DTOR_LIST__,@object
+ __DTOR_LIST__:
+ #endif
+
diff -Naurp linux-2.4/arch/ia64/config.in linux-2.4-gcov/arch/ia64/config.in
--- linux-2.4/arch/ia64/config.in	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4-gcov/arch/ia64/config.in	2004-08-12 17:07:15.840312116 +0200
@@ -269,6 +269,9 @@ if [ "$CONFIG_IA64_HP_SIM" = "n" ]; then
   source drivers/usb/Config.in
 
   source crypto/Config.in
+
+  source drivers/gcov/Config.in
+
   source lib/Config.in
 
   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
diff -Naurp linux-2.4/arch/ia64/kernel/head.S linux-2.4-gcov/arch/ia64/kernel/head.S
--- linux-2.4/arch/ia64/kernel/head.S	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4-gcov/arch/ia64/kernel/head.S	2004-08-12 17:07:15.850312116 +0200
@@ -910,3 +910,24 @@ GLOBAL_ENTRY(ia64_spinlock_contention)
 END(ia64_spinlock_contention)
 
 #endif
+
+#ifdef CONFIG_GCOV_PROFILE
+/*
+ * The .ctors-section contains a list of pointers to constructor
+ * functions which are used to initialize gcov structures.
+ *
+ * Because there is no NULL at the end of the constructor list
+ * in the kernel we need the addresses of both the constructor
+ * as well as the destructor list which are supposed to be
+ * adjacent.
+ */
+
+.section ".ctors","aw"
+.globl  __CTOR_LIST__
+.type   __CTOR_LIST__,@object
+__CTOR_LIST__:
+.section ".dtors","aw"
+.globl  __DTOR_LIST__
+.type   __DTOR_LIST__,@object
+__DTOR_LIST__:
+#endif
diff -Naurp linux-2.4/arch/ppc/boot/chrp/main.c linux-2.4-gcov/arch/ppc/boot/chrp/main.c
--- linux-2.4/arch/ppc/boot/chrp/main.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4-gcov/arch/ppc/boot/chrp/main.c	2004-08-12 17:07:15.860312116 +0200
@@ -34,7 +34,11 @@ char *avail_high;
 
 #define RAM_FREE	((unsigned long)(_end+0x1000)&~0xFFF)
 #define PROG_START	0x00010000
+#ifdef CONFIG_GCOV_ALL
+#define PROG_SIZE	0x00900000 /* 9MB */
+#else
 #define PROG_SIZE	0x00400000 /* 4MB */
+#endif
 
 #define SCRATCH_SIZE	(128 << 10)
 
@@ -42,6 +46,10 @@ static char scratch[SCRATCH_SIZE];	/* 1M
 
 typedef void (*kernel_start_t)(int, int, void *, unsigned int, unsigned int);
 
+#ifdef CONFIG_GCOV_ALL
+void __bb_init_func (void *ptr /* struct bb *blocks */) { }
+#endif
+
 void
 chrpboot(int a1, int a2, void *prom)
 {
@@ -77,7 +85,7 @@ chrpboot(int a1, int a2, void *prom)
 	begin_avail = avail_high = avail_ram;
 	end_avail = scratch + sizeof(scratch);
 	printf("gunzipping (0x%p <- 0x%p:0x%p)...", dst, im, im+len);
-	gunzip(dst, 0x400000, im, &len);
+	gunzip(dst, PROG_SIZE - PROG_START, im, &len);
 	printf("done %u bytes\n\r", len);
 	printf("%u bytes of heap consumed, max in use %u\n\r",
 	       avail_high - begin_avail, heap_max);
diff -Naurp linux-2.4/arch/ppc/config.in linux-2.4-gcov/arch/ppc/config.in
--- linux-2.4/arch/ppc/config.in	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4-gcov/arch/ppc/config.in	2004-08-12 17:07:15.870312116 +0200
@@ -558,6 +558,8 @@ source drivers/media/Config.in
 
 source fs/Config.in
 
+source drivers/gcov/Config.in
+
 mainmenu_option next_comment
 comment 'Sound'
 tristate 'Sound card support' CONFIG_SOUND
diff -Naurp linux-2.4/arch/ppc/kernel/entry.S linux-2.4-gcov/arch/ppc/kernel/entry.S
--- linux-2.4/arch/ppc/kernel/entry.S	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4-gcov/arch/ppc/kernel/entry.S	2004-08-12 17:07:15.880312116 +0200
@@ -272,8 +272,17 @@ ret_from_fork:
 	bl	schedule_tail
 	lwz	r0,TASK_PTRACE(r2)
 	andi.	r0,r0,PT_TRACESYS
+#ifdef CONFIG_GCOV_PROFILE
+	bnel-	syscall_trace_from_fork
+	b	ret_from_fork_to_except
+syscall_trace_from_fork:
+	b	syscall_trace	
+ret_from_fork_to_except:
+	b	ret_from_except
+#else
 	bnel-	syscall_trace
 	b	ret_from_except
+#endif
 
 	.globl	ret_from_intercept
 ret_from_intercept:
diff -Naurp linux-2.4/arch/ppc/kernel/head.S linux-2.4-gcov/arch/ppc/kernel/head.S
--- linux-2.4/arch/ppc/kernel/head.S	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4-gcov/arch/ppc/kernel/head.S	2004-08-12 17:07:15.900312116 +0200
@@ -1801,3 +1801,25 @@ intercept_table:
 abatron_pteptrs:
 	.space	8
 #endif
+
+#ifdef CONFIG_GCOV_PROFILE
+/*     
+ * The .ctors-section contains a list of pointers to constructor
+ * functions which are used to initialize gcov structures.
+ *     
+ * Because there is no NULL at the end of the constructor list
+ * in the kernel we need the addresses of both the constructor
+ * as well as the destructor list which are supposed to be
+ * adjacent.
+ */ 
+
+.section ".ctors","aw"
+.globl  __CTOR_LIST__
+.type   __CTOR_LIST__,@object
+__CTOR_LIST__:
+.section ".dtors","aw"
+.globl  __DTOR_LIST__
+.type   __DTOR_LIST__,@object
+__DTOR_LIST__:
+#endif
+
diff -Naurp linux-2.4/arch/ppc/kernel/prom_init.c linux-2.4-gcov/arch/ppc/kernel/prom_init.c
--- linux-2.4/arch/ppc/kernel/prom_init.c	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4-gcov/arch/ppc/kernel/prom_init.c	2004-08-12 17:07:15.900312116 +0200
@@ -727,7 +727,11 @@ prom_instantiate_rtas(void)
 		 * Actually OF has bugs so we just arbitrarily
 		 * use memory at the 6MB point.
 		 */
+#ifdef CONFIG_GCOV_ALL
+		rtas_data = 0x990000;
+#else
 		rtas_data = 6 << 20;
+#endif
 		prom_print(" at ");
 		prom_print_hex(rtas_data);
 	}
diff -Naurp linux-2.4/arch/ppc64/config.in linux-2.4-gcov/arch/ppc64/config.in
--- linux-2.4/arch/ppc64/config.in	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4-gcov/arch/ppc64/config.in	2004-08-12 17:07:15.920312116 +0200
@@ -261,3 +261,5 @@ fi
 int 'Kernel messages buffer length shift (0 = default)' CONFIG_LOG_BUF_SHIFT 0
 
 endmenu
+
+source drivers/gcov/Config.in
diff -Naurp linux-2.4/arch/ppc64/kernel/head.S linux-2.4-gcov/arch/ppc64/kernel/head.S
--- linux-2.4/arch/ppc64/kernel/head.S	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4-gcov/arch/ppc64/kernel/head.S	2004-08-12 17:07:15.960312116 +0200
@@ -2314,3 +2314,24 @@ hardware_int_paca0:
 	.globl	stab_array
 stab_array:
         .space	4096 * (48 - 1)
+
+#ifdef CONFIG_GCOV_PROFILE
+/*
+ * The .ctors-section contains a list of pointers to constructor
+ * functions which are used to initialize gcov structures.
+ *
+ * Because there is no NULL at the end of the constructor list
+ * in the kernel we need the addresses of both the constructor
+ * as well as the destructor list which are supposed to be
+ * adjacent.
+ */
+
+.section ".ctors","aw"
+.globl  __CTOR_LIST__
+.type   __CTOR_LIST__,@object
+__CTOR_LIST__:
+.section ".dtors","aw"
+.globl  __DTOR_LIST__
+.type   __DTOR_LIST__,@object
+__DTOR_LIST__:
+#endif
diff -Naurp linux-2.4/arch/s390/config.in linux-2.4-gcov/arch/s390/config.in
--- linux-2.4/arch/s390/config.in	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4-gcov/arch/s390/config.in	2004-08-12 17:07:15.980312116 +0200
@@ -86,4 +86,7 @@ int 'Kernel messages buffer length shift
 endmenu
 
 source crypto/Config.in
+
+source drivers/gcov/Config.in
+
 source lib/Config.in
diff -Naurp linux-2.4/arch/s390/kernel/head.S linux-2.4-gcov/arch/s390/kernel/head.S
--- linux-2.4/arch/s390/kernel/head.S	2003-08-25 13:44:40.000000000 +0200
+++ linux-2.4-gcov/arch/s390/kernel/head.S	2004-08-12 17:07:15.990312116 +0200
@@ -671,3 +671,23 @@ _stext:	basr  %r13,0                    
 .Lstart:    .long  start_kernel
 .Laregs:    .long  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 
+#ifdef CONFIG_GCOV_PROFILE
+/*
+ * The .ctors-section contains a list of pointers to constructor
+ * functions which are used to initialize gcov structures.
+ *
+ * Because there is no NULL at the end of the constructor list
+ * in the kernel we need the addresses of both the constructor
+ * as well as the destructor list which are supposed to be
+ * adjacent.
+ */
+
+.section ".ctors","aw"
+.globl  __CTOR_LIST__
+.type   __CTOR_LIST__,@object
+__CTOR_LIST__:
+.section ".dtors","aw"
+.globl  __DTOR_LIST__
+.type   __DTOR_LIST__,@object
+__DTOR_LIST__:
+#endif
diff -Naurp linux-2.4/arch/s390x/config.in linux-2.4-gcov/arch/s390x/config.in
--- linux-2.4/arch/s390x/config.in	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4-gcov/arch/s390x/config.in	2004-08-12 17:07:16.020312116 +0200
@@ -90,4 +90,7 @@ int 'Kernel messages buffer length shift
 endmenu
 
 source crypto/Config.in
+
+source drivers/gcov/Config.in
+
 source lib/Config.in
diff -Naurp linux-2.4/arch/s390x/kernel/head.S linux-2.4-gcov/arch/s390x/kernel/head.S
--- linux-2.4/arch/s390x/kernel/head.S	2004-02-18 14:36:30.000000000 +0100
+++ linux-2.4-gcov/arch/s390x/kernel/head.S	2004-08-12 17:07:16.040312116 +0200
@@ -666,3 +666,23 @@ _stext:	basr  %r13,0                    
 .Ldw:       .quad  0x0002000180000000,0x0000000000000000
 .Laregs:    .long  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 
+#ifdef CONFIG_GCOV_PROFILE
+/*
+ * The .ctors-section contains a list of pointers to constructor
+ * functions which are used to initialize gcov structures.
+ *
+ * Because there is no NULL at the end of the constructor list
+ * in the kernel we need the addresses of both the constructor
+ * as well as the destructor list which are supposed to be
+ * adjacent.
+ */
+
+.section ".ctors","aw"
+.globl  __CTOR_LIST__
+.type   __CTOR_LIST__,@object
+__CTOR_LIST__:
+.section ".dtors","aw"
+.globl  __DTOR_LIST__
+.type   __DTOR_LIST__,@object
+__DTOR_LIST__:
+#endif
diff -Naurp linux-2.4/arch/x86_64/config.in linux-2.4-gcov/arch/x86_64/config.in
--- linux-2.4/arch/x86_64/config.in	2004-02-18 14:36:31.000000000 +0100
+++ linux-2.4-gcov/arch/x86_64/config.in	2004-08-12 17:07:16.000312116 +0200
@@ -251,4 +251,6 @@ int 'Kernel messages buffer length shift
 
 endmenu
 
+source drivers/gcov/Config.in
+
 source lib/Config.in
diff -Naurp linux-2.4/arch/x86_64/kernel/head.S linux-2.4-gcov/arch/x86_64/kernel/head.S
--- linux-2.4/arch/x86_64/kernel/head.S	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4-gcov/arch/x86_64/kernel/head.S	2004-08-12 17:07:16.010312116 +0200
@@ -366,3 +366,24 @@ ENTRY(idt_table)	
 	.quad   0
 	.quad 	0
 	.endr		
+
+#ifdef CONFIG_GCOV_PROFILE
+/*
+ * The .ctors-section contains a list of pointers to constructor
+ * functions which are used to initialize gcov structures.
+ *
+ * Because there is no NULL at the end of the constructor list
+ * in the kernel we need the addresses of both the constructor
+ * as well as the destructor list which are supposed to be
+ * adjacent.
+ */
+
+.section ".ctors","aw"
+globl  __CTOR_LIST__
+type   __CTOR_LIST__,@object
+_CTOR_LIST__:
+.section ".dtors","aw"
+.globl  __DTOR_LIST__
+.type   __DTOR_LIST__,@object
+__DTOR_LIST__:
+#endif
diff -Naurp linux-2.4/drivers/Makefile linux-2.4-gcov/drivers/Makefile
--- linux-2.4/drivers/Makefile	2003-11-28 19:26:19.000000000 +0100
+++ linux-2.4-gcov/drivers/Makefile	2004-08-12 17:07:16.490312116 +0200
@@ -8,7 +8,7 @@
 
 mod-subdirs :=	dio hil mtd sbus video macintosh usb input telephony ide \
 		message/i2o message/fusion scsi md ieee1394 pnp isdn atm \
-		fc4 net/hamradio i2c acpi bluetooth usb/gadget
+		fc4 net/hamradio i2c acpi bluetooth usb/gadget gcov
 
 subdir-y :=	parport char block net sound misc media cdrom hotplug
 subdir-m :=	$(subdir-y)
@@ -49,4 +49,6 @@ subdir-$(CONFIG_ACPI_BOOT)	+= acpi
 
 subdir-$(CONFIG_BLUEZ)		+= bluetooth
 
+subdir-$(CONFIG_GCOV_PROFILE)	+= gcov
+
 include $(TOPDIR)/Rules.make
diff -Naurp linux-2.4/drivers/gcov/Config.in linux-2.4-gcov/drivers/gcov/Config.in
--- linux-2.4/drivers/gcov/Config.in	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4-gcov/drivers/gcov/Config.in	2004-08-12 17:07:19.370312116 +0200
@@ -0,0 +1,13 @@
+#
+# GCOV coverage profiling
+#
+
+mainmenu_option next_comment
+comment 'GCOV coverage profiling'
+ 
+bool 'GCOV kernel' CONFIG_GCOV_PROFILE
+if [ "$CONFIG_GCOV_PROFILE" != "n" ]; then
+   bool '  Profile entire Kernel' CONFIG_GCOV_ALL
+   tristate '  Provide GCOV proc file system entry' CONFIG_GCOV_PROC
+fi
+endmenu
diff -Naurp linux-2.4/drivers/gcov/Makefile linux-2.4-gcov/drivers/gcov/Makefile
--- linux-2.4/drivers/gcov/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4-gcov/drivers/gcov/Makefile	2004-08-12 17:07:19.400312116 +0200
@@ -0,0 +1,15 @@
+#
+# Makefile for GCOV profiling kernel module
+#
+
+O_TARGET			:= gcov.o
+
+export-objs			+= gcov-core.o
+
+obj-$(CONFIG_GCOV_PROFILE)	+= gcov-core.o
+obj-$(CONFIG_GCOV_PROC)		+= gcov-proc.o
+
+CFLAGS_gcov-core.o := -DGCOV_SRC_PATH='"$(TOPDIR)"' \
+		      -DGCOV_OBJ_PATH='"$(TOPDIR)"'
+
+include $(TOPDIR)/Rules.make
diff -Naurp linux-2.4/drivers/gcov/gcov-core.c linux-2.4-gcov/drivers/gcov/gcov-core.c
--- linux-2.4/drivers/gcov/gcov-core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4-gcov/drivers/gcov/gcov-core.c	2004-08-12 17:07:19.310312116 +0200
@@ -0,0 +1,246 @@
+/*
+ * drivers/gcov/gcov-core.c
+ *
+ * Core functionality for GCOV kernel profiling.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (c) International Business Machines Corp., 2002-2003
+ *
+ * Author: Hubertus Franke <frankeh@us.ibm.com>
+ *         Rajan Ravindran <rajancr@us.ibm.com>
+ *         Peter Oberparleiter <Peter.Oberparleiter@de.ibm.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/gcov.h>
+#include <asm/semaphore.h>
+
+
+#define GCOV_CORE_HEADER	"gcov-core: "
+
+/* This structure is used to keep track of all struct bbs associated with a
+ * module. */
+struct gcov_context
+{
+	struct list_head list;
+	struct module *module;
+	unsigned long count;
+	struct bb **bb;
+};
+
+/* Start of global constructor list. Has to be declared in arch/kernel/head.S */
+extern char __CTOR_LIST__;
+
+/* End of global constructor list. Has to be declared in arch/kernel/head.S */
+extern char __DTOR_LIST__;
+
+/* Linked list for registered struct bbs. */
+struct bb *bb_head;
+
+/* Callback informed of struct bb addition and removal. */
+void (*gcov_callback)(enum gcov_cmd, struct bb *bbptr) = NULL;
+
+/* Path to kernel files. */
+const char *gcov_sourcepath = GCOV_SRC_PATH;
+const char *gcov_objectpath = GCOV_OBJ_PATH;
+
+/* List of contexts for registered bb entries. */
+static LIST_HEAD(context_list);
+
+/* Context into which blocks are inserted during initialization. */
+static struct gcov_context *current_context;
+
+/* Protect global variables from concurrent access. */
+DECLARE_MUTEX(gcov_core_lock);
+
+#if GCC_VERSION_LOWER(3, 4)
+/* Register supplied struct BB. Called by each object code constructor. */
+void
+__bb_init_func(struct bb *bb)
+{
+	if (bb->zero_word)
+		return;
+	/* Set up linked list */
+	bb->zero_word = 1;
+	bb->next = bb_head;
+	bb_head = bb;
+	/* Associate with module context */
+	if (current_context)
+		current_context->bb[current_context->count++] = bb;
+	/* Notify callback */
+	if (gcov_callback != NULL)
+		(*gcov_callback)(gcov_add, bb);
+}
+
+
+/* Unused functions needed to prevent linker errors. */
+void __bb_fork_func(void) {}
+
+EXPORT_SYMBOL_NOVERS(__bb_init_func);
+EXPORT_SYMBOL_NOVERS(__bb_fork_func);
+#else
+gcov_unsigned_t gcov_version = 0;
+
+/* Register supplied struct BB. Called by each object code constructor. */
+void
+__gcov_init(struct bb *bb)
+{
+	if (!bb->version)
+		return;
+	/* Check for compatible gcc version */
+	if (gcov_version == 0)
+		gcov_version = bb->version;
+	else if (bb->version != gcov_version) {
+		printk(KERN_WARNING GCOV_CORE_HEADER "gcc version mismatch in "
+		       " file '%s'!\n", bb->filename);
+		return;
+	}
+	/* Set up linked list */
+	bb->version = 0;
+	bb->next = bb_head;
+	bb_head = bb;
+	/* Associate with module context */
+	if (current_context)
+		current_context->bb[current_context->count++] = bb;
+	/* Notify callback */
+	if (gcov_callback != NULL)
+		(*gcov_callback)(gcov_add, bb);
+}
+
+
+/* Unused functions needed to prevent linker errors. */
+void __gcov_flush(void) {}
+void __gcov_merge_add(gcov_type *counters, unsigned int n_counters) {}
+void __gcov_merge_single(gcov_type *counters, unsigned int n_counters) {}
+void __gcov_merge_delta(gcov_type *counters, unsigned int n_counters) {}
+
+EXPORT_SYMBOL_NOVERS(gcov_version);
+EXPORT_SYMBOL_NOVERS(__gcov_init);
+EXPORT_SYMBOL_NOVERS(__gcov_flush);
+EXPORT_SYMBOL_NOVERS(__gcov_merge_add);
+EXPORT_SYMBOL_NOVERS(__gcov_merge_single);
+EXPORT_SYMBOL_NOVERS(__gcov_merge_delta);
+#endif /* GCC_VERSION_LOWER */
+
+
+/* Call all constructor function pointers stored between CTORS_START and
+ * CTORS_END. If specified, associate resulting bb data with MODULE. */
+void
+do_global_ctors(const char *ctors_start, const char *ctors_end,
+		struct module *module)
+{
+	typedef void (*func_ptr)(void);
+	func_ptr *func;
+	unsigned long count;
+
+	down(&gcov_core_lock);
+	if (module) {
+		/* Create a context to associate struct bbs with this MODULE */
+		count = ((unsigned long) (ctors_end - ctors_start)) /
+			sizeof(func_ptr);
+		current_context = (struct gcov_context*) kmalloc(
+					sizeof(struct gcov_context) +
+					count * sizeof(struct bb *),
+					GFP_KERNEL);
+		if (!current_context) {
+			printk(KERN_WARNING GCOV_CORE_HEADER "not enough memory"
+			       " for coverage data!\n");
+			up(&gcov_core_lock);
+			return;
+		}
+		current_context->module = module;
+		current_context->count = 0;
+		current_context->bb = (struct bb **) (current_context + 1);
+		list_add(&current_context->list, &context_list);
+	}
+	/* Call constructors */
+	for (func = (func_ptr *) ctors_start;
+	     *func && (func != (func_ptr *) ctors_end); func++)
+		(*func)();
+	current_context = NULL;
+	up(&gcov_core_lock);
+}
+
+
+/* Remove data associated with MODULE. */
+void
+remove_bb_link(struct module *module)
+{
+	struct gcov_context* context;
+	struct gcov_context* tmp;
+	struct bb *bb;
+	struct bb *prev;
+	unsigned long i;
+
+	down(&gcov_core_lock);
+	/* Get associated context */
+	context = NULL;
+	list_for_each_entry(tmp, &context_list, list) {
+		if (tmp->module == module) {
+			context = tmp;
+			break;
+		}
+	}
+	if (!context) {
+		up(&gcov_core_lock);
+		return;
+	}
+	/* Remove all bb entries belonging to this module */
+	prev = NULL;
+	for (bb = bb_head; bb ; bb = bb->next) {
+		for (i = 0; i < context->count; i++) {
+			if (context->bb[i] == bb) {
+				/* Detach bb from list. */
+				if (prev)
+					prev->next = bb->next;
+				else
+					bb_head = bb->next;
+				/* Notify callback */
+				if (gcov_callback)
+					(*gcov_callback)(gcov_remove, bb);
+				break;
+			}
+		}
+		if (i == context->count)
+			prev = bb;
+	}
+	list_del(&context->list);
+	kfree(context);
+	up(&gcov_core_lock);
+}
+
+
+static int __init
+gcov_core_init(void)
+{
+	printk(KERN_INFO GCOV_CORE_HEADER "initializing core module\n");
+	do_global_ctors(&__CTOR_LIST__, &__DTOR_LIST__, NULL);
+	return 0;
+}
+
+module_init(gcov_core_init);
+
+
+EXPORT_SYMBOL_NOVERS(bb_head);
+EXPORT_SYMBOL_NOVERS(gcov_sourcepath);
+EXPORT_SYMBOL_NOVERS(gcov_objectpath);
+EXPORT_SYMBOL_NOVERS(gcov_callback);
+EXPORT_SYMBOL_NOVERS(gcov_core_lock);
+EXPORT_SYMBOL_NOVERS(do_global_ctors);
diff -Naurp linux-2.4/drivers/gcov/gcov-proc.c linux-2.4-gcov/drivers/gcov/gcov-proc.c
--- linux-2.4/drivers/gcov/gcov-proc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4-gcov/drivers/gcov/gcov-proc.c	2004-08-12 17:07:19.300312116 +0200
@@ -0,0 +1,1596 @@
+/*
+ * drivers/gcov/gcov-proc.c
+ *
+ * Provides proc filesystem entry for GCOV kernel profiling.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (c) International Business Machines Corp., 2002-2003
+ *
+ * Author: Hubertus Franke <frankeh@us.ibm.com>
+ *         Rajan Ravindran <rajancr@us.ibm.com>
+ *         Peter Oberparleiter <Peter.Oberparleiter@de.ibm.com>
+ *         Paul Larson
+ */
+
+#include <linux/config.h>
+#if CONFIG_MODVERSIONS==1
+#define MODVERSIONS
+#include <linux/modversions.h>
+#endif
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/gcov.h>
+
+
+MODULE_LICENSE("GPL");
+
+#define GCOV_PROC_HEADER	"gcov-proc: "
+#define GCOV_PROC_ROOT		"gcov"
+#define GCOV_PROC_MODULE	"module"
+#define GCOV_PROC_VMLINUX	"vmlinux"
+#define PAD8(x)			(((x) + 7) & ~7)
+#define PAD4(x)			(((x) + 3) & ~3)
+
+typedef enum {
+	status_normal,	/* Normal status */
+	status_ghost	/* Module associated with this node has been unloaded
+			 * but data was saved. */
+} node_status;
+
+/* Data structure used to manage proc filesystem entries. */
+struct gcov_ftree_node
+{
+	char *fname;			 /* Hierarchy-relative name */
+	struct gcov_ftree_node *sibling; /* First sibling of this node */
+	struct gcov_ftree_node *files;	 /* First child of this node */
+	struct gcov_ftree_node *parent;	 /* Parent of this node */
+	struct proc_dir_entry *proc[4];	 /* Entries for .da, .bb, .bbg, .c */
+	struct bb *bb;			 /* Associated struct bb */
+	loff_t offset;			 /* Offset in vmlinux file */
+	size_t da_size;			 /* Size of associated .da file */
+	size_t header_size;		 /* Size of associated file header */
+	struct gcov_ftree_node *next;	 /* Next leaf node */
+	node_status status;		 /* Status of this node */
+};
+
+
+/* If set to non-zero, keep gcov data for modules after unload. */
+static int gcov_persist = 0;
+
+/* If set to non-zero, create links to additional files in proc filesystem
+ * entries. */
+static int gcov_link = 1;
+
+/* Protect global variables from concurrent access. */
+static DECLARE_MUTEX_LOCKED(gcov_lock);
+
+/* Length of kernel source path string. */
+static int sourcepath_len;
+
+/* Length of kernel object path string. */
+static int objectpath_len;
+
+/* Filesystem entry for /proc/vmlinux */
+static struct proc_dir_entry *proc_vmlinux = NULL;
+
+/* First leaf node. */
+static struct gcov_ftree_node *leaf_nodes = NULL;
+
+/* Cached node used to speed up sequential reads in /proc/vmlinux. */
+static struct gcov_ftree_node *cached_node = NULL;
+
+/* Root node for internal data tree. */
+static struct gcov_ftree_node tree_root;
+
+#if GCC_VERSION_LOWER(3,4)
+/* Filename extension for data files. */
+static const char *da_ending = "da";
+
+/* Array of filename endings to use when creating links. */
+static const char *endings[] = { "bb", "bbg", "c" };
+#else
+/* Filename extension for data files. */
+static const char *da_ending = "gcda";
+
+/* Array of filename endings to use when creating links. */
+static const char *endings[] = { "gcno", "c" };
+#endif /* GCC_VERSION_LOWER */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)) &&	\
+    (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,4)) ||	\
+    (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,23))
+/* Retrieve proc_dir_entry associated with INODE. */
+static inline struct proc_dir_entry *
+PDE(const struct inode *inode)
+{
+	return ((struct proc_dir_entry *) inode->u.generic_ip);
+}
+#endif
+
+
+#ifdef MODULE
+/* Parameter handling. */
+MODULE_PARM(gcov_persist, "i");
+MODULE_PARM_DESC(gcov_persist, "If set to non-zero, keep gcov data for modules "
+			       "after unload");
+MODULE_PARM(gcov_link, "i");
+MODULE_PARM_DESC(gcov_link, "If set to non-zero, create links to additional "
+			    "files in proc filesystem entries");
+
+#else
+
+/* Called when 'gcov_persist' is specified on the kernel command line. */
+static int __init
+gcov_persist_setup(char *str)
+{
+	gcov_persist = (int) simple_strtol(str, NULL, 10);
+	return 1;
+}
+
+__setup("gcov_persist=", gcov_persist_setup);
+
+
+/* Called when 'gcov_link' is specified on the kernel command line. */
+static int __init
+gcov_link_setup(char *str)
+{
+	gcov_link = (int) simple_strtol(str, NULL, 10);
+	return 1;
+}
+
+__setup("gcov_link=", gcov_link_setup);
+#endif /* MODULE */
+
+
+/* Store a portable representation of VALUE in DEST using BYTES*8-1 bits.
+ * Return a non-zero value if VALUE requires more than BYTES*8-1 bits
+ * to store (adapted from gcc/gcov-io.h). */
+static int
+store_gcov_type(gcov_type value, char *dest, size_t bytes)
+{
+	int upper_bit = (value < 0 ? 128 : 0);
+	size_t i;
+
+	if (value < 0) {
+		gcov_type oldvalue = value;
+		value = -value;
+		if (oldvalue != -value)
+			return 1;
+	}
+
+	for (i = 0 ; i < (sizeof(value) < bytes ? sizeof(value) : bytes) ;
+	     i++) {
+		dest[i] = value & (i == (bytes - 1) ? 127 : 255);
+		value = value / 256;
+	}
+
+	if (value && value != -1)
+		return 1;
+
+	for(; i < bytes ; i++)
+		dest[i] = 0;
+	dest[bytes - 1] |= upper_bit;
+	return 0;
+}
+
+
+/* Return size of header which precedes .da file entry associated with BB
+ * in the vmlinux file. */
+static inline size_t
+sizeof_vmlinux_header(struct bb *bb)
+{
+	return 8 + PAD8(strlen(bb->filename) + 1);
+}
+
+
+/* Store data of header which precedes .da file entry associated with NODE
+ * in the vmlinux file to userspace memory at BUF. OFFSET specifies the offset
+ * inside the header file. COUNT is the maximum number of bytes to store.
+ * Return the number of bytes stored, zero for EOF or a negative number in
+ * case of error. */
+static ssize_t
+store_vmlinux_header(struct gcov_ftree_node *node, char *buf, size_t count,
+		     loff_t offset)
+{
+	char data[8];
+	char *from;
+	size_t namelen;
+	ssize_t stored;
+	size_t len;
+
+	namelen = strlen(node->bb->filename);
+	stored = 0;
+	while (count > 0) {
+		if (offset < 8) {
+			/* Filename length */
+			if (store_gcov_type(PAD8(namelen + 1), data, 8))
+				return -EINVAL;
+			from = data + offset;
+			len = 8 - offset;
+		} else if (offset < 8 + namelen) {
+			/* Filename */
+			from = (char *) node->bb->filename + offset - 8;
+			len = namelen - (offset - 8);
+		} else if (offset < node->header_size) {
+			/* Nil byte padding */
+			memset(data, 0, 8);
+			from = data;
+			len = PAD8(namelen + 1) - (offset - 8);
+		} else
+			break;
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		stored += len;
+		count -= len;
+		offset += len;
+		buf += len;
+	}
+
+	return stored;
+}
+
+
+#if GCC_VERSION_LOWER(3, 3)
+/*
+ *  pre-gcc 3.3 functions
+ */
+
+
+/* Return size of .da file associated with BB. */
+static inline size_t
+sizeof_da_file(struct bb *bb)
+{
+	return (bb->ncounts + 1) * 8;
+}
+
+
+/* Store data of .da file associated with NODE to userspace memory at BUF.
+ * OFFSET specifies the offset inside the .da file. COUNT is the maximum
+ * number of bytes to store. Return the number of bytes stored, zero for
+ * EOF or a negative number in case of error. */
+static ssize_t
+store_da_file(struct gcov_ftree_node *node, char *buf, size_t count,
+	      loff_t offset)
+{
+	char data[8];
+	char *from;
+	ssize_t stored;
+	size_t len;
+
+	stored = 0;
+	while (count > 0) {
+		if (offset < 8) {
+			/* Number of counts */
+			if (store_gcov_type(node->bb->ncounts, data, 8))
+				return -EINVAL;
+			from = data + offset;
+			len = 8 - offset;
+		} else if (offset < node->da_size) {
+			/* Count data */
+			if (store_gcov_type(node->bb->counts[(offset - 8) / 8],
+					    data, 8))
+				return -EINVAL;
+			from = data + offset % 8;
+			len = 8 - offset % 8;
+		} else
+			break;
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		stored += len;
+		count -= len;
+		offset += len;
+		buf += len;
+	}
+	return stored;
+}
+
+#elif GCC_VERSION_LOWER(3, 4)
+/*
+ *   gcc 3.3 specific functions
+ */
+
+
+/* Return size of .da file section associated with function data FUNC. */
+static inline size_t
+sizeof_func_info(struct bb_function_info *func)
+{
+	return (size_t)
+	       (/* delim */ 4 + /* strlen */ 4 + PAD4(strlen(func->name) + 1) +
+	        /* delim */ 4 + /* checksum */ 4 + /* arc_count */ 4 +
+	        /* count values */ func->arc_count * 8);
+}
+
+
+/* Return size of .da file associated with BB. */
+static inline size_t
+sizeof_da_file(struct bb *bb)
+{
+	struct bb_function_info *func;
+	size_t size;
+
+	size = ( /* magic */ 4 + /* num_func */ 4 + /* num_extra */ 4);
+	for (func = bb->function_infos; func->arc_count != -1; func++)
+		size += sizeof_func_info(func);
+	return size;
+}
+
+
+/* Return the number of functions associated with BB. */
+static inline gcov_type
+count_functions(struct bb *bb)
+{
+	gcov_type result;
+
+	for (result = 0; bb->function_infos[result].arc_count != -1;
+	     result++);
+	return result;
+}
+
+
+/* Return non-zero if OFFSET is within the range START <= OFFSET < START + SIZE,
+ * zero otherwise. Update REL_OFF to contain the relative offset inside the
+ * range, SIZE_VAR to contain the range size and START to point to the next
+ * range after this one. */
+static inline int in_range(loff_t offset, size_t size, loff_t *rel_off,
+			   loff_t *start, size_t *size_var)
+{
+	int result;
+
+	result = (offset >= *start) && (offset < *start + size);
+	*rel_off = offset - *start;
+	*start += size;
+	*size_var = size;
+	return result;
+}
+
+
+/* Store data of .da file associated with NODE to userspace memory at BUF.
+ * OFFSET specifies the offset inside the .da file. COUNT is the maximum
+ * number of bytes to store. Return the number of bytes stored, zero for
+ * EOF or a negative number in case of error. */
+static ssize_t
+store_da_file(struct gcov_ftree_node *node, char *buf, size_t count,
+	      loff_t offset)
+{
+	struct bb_function_info *func;
+	gcov_type *count_ptr;
+	char data[8];
+	char *from;
+	ssize_t stored;
+	size_t len;
+	size_t size;
+	size_t func_off;
+	size_t next_off;
+	loff_t rel_off;
+	loff_t start;
+
+	func_off = 0;
+	func = NULL;
+	count_ptr = NULL;
+	stored = 0;
+	while (count > 0) {
+		start = 0;
+		if (in_range(offset, 4, &rel_off, &start, &size)) {
+			/* Magic */
+			if (store_gcov_type(-123, data, 4))
+				return -EINVAL;
+			from = data + rel_off;
+			len = size - rel_off;
+		} else if (in_range(offset, 4, &rel_off, &start, &size)) {
+			/* Number of functions */
+			if (store_gcov_type(count_functions(node->bb),
+					    data, 4))
+				return -EINVAL;
+			from = data + rel_off;
+			len = size - rel_off;
+		} else if (in_range(offset, 4, &rel_off, &start, &size)) {
+			/* Size of extra data */
+			store_gcov_type(0, data, 4);
+			from = data + rel_off;
+			len = size - rel_off;
+		} else if (offset < node->da_size) {
+			/* Function data */
+			rel_off = offset - 12;
+			/* Try to minimize search effort */
+			if (!(func && (func_off <= rel_off))) {
+				func = node->bb->function_infos;
+				func_off = 0;
+				count_ptr = node->bb->counts;
+			}
+			/* Find function which is hit by offset */
+			for (; func->arc_count != -1; func++) {
+				next_off = func_off + sizeof_func_info(func);
+				if (next_off > rel_off)
+					break;
+				func_off = next_off;
+				count_ptr += func->arc_count;
+			}
+			start = 0;
+			if (in_range(offset - func_off - 12, 4, &rel_off,
+				     &start, &size)) {
+				/* String delimiter */
+				store_gcov_type(-1, data, 4);
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12, 4, &rel_off,
+				   &start, &size)) {
+				/* String length */
+				if (store_gcov_type(strlen(func->name),
+						    data, 4))
+					return -EINVAL;
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12,
+				   strlen(func->name), &rel_off, &start,
+				   &size)) {
+				/* Function name */
+				from = (char *) func->name + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12,
+				   PAD4(strlen(func->name) + 1) -
+				   strlen(func->name), &rel_off, &start,
+				   &size)) {
+				/* Nil byte padding */
+				memset(data, 0, size);
+				from = data;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12, 4, &rel_off,
+				   &start, &size)) {
+				/* String delimiter */
+				store_gcov_type(-1, data, size);
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12, 4, &rel_off,
+				   &start, &size)) {
+				/* Checksum */
+				store_gcov_type(func->checksum, data, 4);
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12, 4, &rel_off,
+				   &start, &size)) {
+				/* Number of arcs */
+				if (store_gcov_type(func->arc_count, data, 4))
+					return -EINVAL;
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12,
+				   func->arc_count * 8, &rel_off, &start,
+				   &size)) {
+				/* Counts */
+				if (store_gcov_type(count_ptr[rel_off / 8],
+						    data, 8))
+					return -EINVAL;
+				from = data + rel_off % 8;
+				len = 8 - rel_off % 8;
+			} else {
+				break;
+			}
+		} else
+			break;
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		stored += len;
+		count -= len;
+		offset += len;
+		buf += len;
+	}
+	return stored;
+}
+#else
+/*
+ *  gcc 3.4 functions
+ */
+
+/* Determine whether counter TYPE is active in BB. */
+static inline int
+counter_active(struct bb *bb, unsigned int type)
+{
+	return (1 << type) & bb->ctr_mask;
+}
+
+
+/* Return the number of active counter types for BB. */
+static inline unsigned int
+num_counter_active(struct bb *bb)
+{
+	unsigned int i;
+	unsigned int result;
+
+	result = 0;
+	for (i=0; i < GCOV_COUNTERS; i++)
+		if (counter_active(bb, i))
+			result++;
+	return result;
+}
+
+
+/* Get number of bytes used for one entry in the gcov_fn_info array pointed to
+ * by BB->functions. */
+static inline unsigned int
+get_fn_stride(struct bb *bb)
+{
+	unsigned int stride;
+
+	stride = sizeof(struct gcov_fn_info) + num_counter_active(bb) *
+		 sizeof(unsigned int);
+	if (__alignof__(struct gcov_fn_info) > sizeof(unsigned int)) {
+		stride += __alignof__(struct gcov_fn_info) - 1;
+		stride &= ~(__alignof__(struct gcov_fn_info) - 1);
+	}
+	return stride;
+}
+
+
+/* Get the address of gcov_fn_info for function FUNC of BB. */
+static inline struct gcov_fn_info *
+get_fn_info(struct bb *bb, unsigned int func)
+{
+	return (struct gcov_fn_info *)
+		((char *) bb->functions + func * get_fn_stride(bb));
+}
+
+
+/* Return size of .gcda counter section. */
+static inline size_t
+sizeof_counter_data(struct bb *bb, struct gcov_fn_info *func, unsigned int type)
+{
+	if (counter_active(bb, type)) {
+		return /* tag */ 4 + /* length */ 4 +
+		       /* counters */ func->n_ctrs[type] * 8;
+	} else
+		return 0;
+}
+
+
+/* Return size of .gcda data section associated with FUNC.  */
+static inline size_t
+sizeof_func_data(struct bb *bb, struct gcov_fn_info *func)
+{
+	size_t result;
+	unsigned int type;
+
+	result = /* tag */ 4 + /* length */ 4 + /* ident */ 4+
+		 /* checksum */ 4;
+	for (type=0; type < GCOV_COUNTERS; type++)
+		result += sizeof_counter_data(bb, func, type);
+	return result;
+}
+
+
+/* Get size of .gcda file associated with BB. */
+static inline size_t
+sizeof_da_file(struct bb *bb)
+{
+	size_t result;
+	unsigned int i;
+
+	result = /* magic */ 4 + /* version */ 4 + /* stamp */ 4;
+	for (i=0; i < bb->n_functions; i++)
+		result += sizeof_func_data(bb, get_fn_info(bb, i));
+	return result;
+}
+
+
+/* Store a 32 bit unsigned integer value in GCOV format to memory at address
+ * BUF. */
+static inline void
+store_int32(uint32_t i, char *buf)
+{
+	uint32_t *p;
+
+	p = (int *) buf;
+	*p = i;
+}
+
+
+/* Store a 64 bit unsigned integer value in GCOV format to memory at address
+ * BUF. */
+static inline void
+store_int64(uint64_t i, char *buf)
+{
+	store_int32((uint32_t) (i & 0xffff), buf);
+	store_int32((uint32_t) (i >> 32), buf + 4);
+}
+
+
+/* Store a gcov counter in GCOV format to memory at address BUF. The counter is
+ * identified by BB, FUNC, TYPE and COUNTER. */
+static inline void
+store_counter(struct bb *bb, unsigned int func, unsigned int type,
+	      unsigned int counter, char *buf)
+{
+	unsigned int counter_off;
+	unsigned int type_off;
+	unsigned int i;
+
+	/* Get offset into counts array */
+	type_off = 0;
+	for (i=0; i < type; i++)
+		if (counter_active(bb, i))
+			type_off++;
+	/* Get offset into values array. */
+	counter_off = counter;
+	for (i=0; i < func; i++)
+		counter_off += get_fn_info(bb, i)->n_ctrs[type];
+	/* Create in temporary storage */
+	store_int64(bb->counts[type_off].values[counter_off], buf);
+}
+
+
+/* Store a counter section in userspace memory. The counter section is
+ * identified by BB, FUNC and TYPE. The destination address is BUF. Store at
+ * most COUNT bytes beginning at OFFSET. Return the number of bytes stored or a
+ * negative value on error. */
+static inline ssize_t
+store_counter_data(struct bb *bb, unsigned int func, unsigned int type,
+		  char *buf, size_t count, loff_t offset)
+{
+	struct gcov_fn_info *func_ptr;
+	char data[8];
+	char *from;
+	size_t len;
+	ssize_t result;
+	unsigned int i;
+
+	result = 0;
+	func_ptr = get_fn_info(bb, func);
+	while (count > 0) {
+		if (offset < 4) {
+			/* Tag ID */
+			store_int32((uint32_t) GCOV_TAG_FOR_COUNTER(type),
+				    data);
+			len = 4 - offset;
+			from = data + offset;
+		} else if (offset < 8) {
+			/* Tag length in groups of 4 bytes */
+			store_int32((uint32_t)
+				    func_ptr->n_ctrs[type] * 2, data);
+			len = 4 - (offset - 4);
+			from = data + (offset - 4);
+		} else {
+			/* Actual counter data */
+			i = (offset - 8) / 8;
+			/* Check for EOF */
+			if (i >= func_ptr->n_ctrs[type])
+				break;
+			store_counter(bb, func, type, i, data);
+			len = 8 - (offset - 8) % 8;
+			from = data + (offset - 8) % 8;
+		} 
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+
+
+/* Store a function section and associated counter sections in userspace memory.
+ * The function section is identified by BB and FUNC. The destination address is
+ * BUF. Store at most COUNT bytes beginning at OFFSET. Return the number of
+ * bytes stored or a negative value on error. */
+static inline ssize_t
+store_func_data(struct bb *bb, unsigned int func, char *buf,
+		size_t count, loff_t offset)
+{
+	struct gcov_fn_info *func_ptr;
+	char data[4];
+	char *from;
+	size_t len;
+	unsigned int i;
+	loff_t off;
+	size_t size;
+	ssize_t result;
+	ssize_t rc;
+
+	func_ptr = get_fn_info(bb, func);
+	result = 0;
+	while (count > 0) {
+		if (offset < 16) {
+			if (offset < 4) {
+				/* Tag ID */
+				store_int32((uint32_t) GCOV_TAG_FUNCTION, data);
+				len = 4 - offset;
+				from = data + offset;
+			} else if (offset < 8) {
+				/* Tag length */
+				store_int32(2, data);
+				len = 4 - (offset - 4);
+				from = data + (offset - 4);
+			} else if (offset < 12) {
+				/* Function ident */
+				store_int32((uint32_t) func_ptr->ident, data);
+				len = 4 - (offset - 8);
+				from = data + (offset - 8);
+			} else {
+				/* Function checksum */
+				store_int32((uint32_t) func_ptr->checksum,
+					    data);
+				len = 4 - (offset - 12);
+				from = data + (offset - 12);
+			}
+			/* Do the actual store */
+			if (len > count)
+				len = count;
+			if (copy_to_user(buf, from, len))
+				return -EFAULT;
+		} else {
+			off = 16;
+			len = 0;
+			for (i=0; i < GCOV_COUNTERS; i++) {
+				size = sizeof_counter_data(bb, func_ptr, i);
+				if (offset < off + size) {
+					rc = store_counter_data(bb, func, i,
+								buf, count,
+								offset - off);
+					if (rc < 0)
+						return rc;
+					len = rc;
+					break;
+				}
+				off += size;
+			}
+			/* Check for EOF */
+			if (i == GCOV_COUNTERS)
+				break;
+		}
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+
+
+/* Store data of .gcda file associated with NODE to userspace memory at BUF.
+ * OFFSET specifies the offset inside the .da file. COUNT is the maximum
+ * number of bytes to store. Return the number of bytes stored, zero for
+ * EOF or a negative number in case of error. */
+static ssize_t
+store_da_file(struct gcov_ftree_node *node, char *buf, size_t count,
+	      loff_t offset)
+{
+	struct bb *bb;
+	char data[4];
+	char *from;
+	size_t len;
+	unsigned int i;
+	loff_t off;
+	size_t size;
+	ssize_t result;
+	ssize_t rc;
+
+	bb = node->bb;
+	result = 0;
+	while (count > 0) {
+		if (offset < 12) {
+			if (offset < 4) {
+				/* File magic */
+				store_int32((uint32_t) GCOV_DATA_MAGIC, data);
+				len = 4 - offset;
+				from = data + offset;
+			} else if (offset < 8) {
+				/* File format/GCC version */
+				store_int32(gcov_version, data);
+				len = 4 - (offset - 4);
+				from = data + (offset - 4);
+			} else {
+				/* Time stamp */
+				store_int32((uint32_t) bb->stamp, data);
+				len = 4 - (offset - 8);
+				from = data + (offset - 8);
+			}
+			/* Do the actual store */
+			if (len > count)
+				len = count;
+			if (copy_to_user(buf, from, len))
+				return -EFAULT;
+		} else {
+			off = 12;
+			len = 0;
+			for (i=0; i < bb->n_functions; i++) {
+				size = sizeof_func_data(bb, get_fn_info(bb, i));
+				if (offset < off + size) {
+					rc = store_func_data(bb, i, buf, count,
+							     offset - off);
+					if (rc < 0)
+						return rc;
+					len = rc;
+					break;
+				}
+				off += size;
+			}
+			/* Check for EOF */
+			if (i == bb->n_functions)
+				break;
+		}
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+#endif /* if GCC_VERSION_LOWER */
+
+
+/* Update data related to vmlinux file. */
+static void
+update_vmlinux_data(void)
+{
+	struct gcov_ftree_node *node;
+	loff_t offset;
+
+	offset = 0;
+	for (node = leaf_nodes; node; node = node->next) {
+		node->offset = offset;
+		node->da_size = sizeof_da_file(node->bb);
+		node->header_size = sizeof_vmlinux_header(node->bb);
+		offset += node->header_size + node->da_size;
+	}
+	proc_vmlinux->size = offset;
+	cached_node = NULL;
+}
+
+
+/* Read .da or vmlinux file. */
+static ssize_t
+read_gcov(struct file *file, char *buf, size_t count, loff_t *pos)
+{
+	struct gcov_ftree_node *node;
+	struct proc_dir_entry *dir_entry;
+	ssize_t rc;
+
+	down(&gcov_lock);
+	dir_entry = PDE(file->f_dentry->d_inode);
+	rc = 0;
+	if (dir_entry == proc_vmlinux) {
+		/* Are we in a sequential read? */
+		if (cached_node && (*pos >= cached_node->offset))
+			node = cached_node;
+		else
+			node = leaf_nodes;
+		/* Find node corresponding to offset */
+		while (node && node->next && (*pos >= node->next->offset))
+			node = node->next;
+		cached_node = node;
+		if (node) {
+			if (*pos - node->offset < node->header_size)
+				rc = store_vmlinux_header(node, buf, count,
+							  *pos - node->offset);
+			else
+				rc = store_da_file(node, buf, count,
+						   *pos - node->offset -
+							node->header_size);
+		}
+	} else {
+		node = (struct gcov_ftree_node *) dir_entry->data;
+		if (node)
+			rc = store_da_file(node, buf, count, *pos);
+	}
+	if (rc > 0)
+		*pos += rc;
+	up(&gcov_lock);
+	return rc;
+}
+
+
+static inline void
+reset_bb(struct bb* bb)
+{
+#if GCC_VERSION_LOWER(3, 4)
+	memset(bb->counts, 0, bb->ncounts * sizeof(gcov_type));
+#else
+	const struct gcov_ctr_info *ctr;
+	unsigned int i;
+
+	ctr = bb->counts;
+	for (i=0; i < GCOV_COUNTERS; i++)
+		if (counter_active(bb, i)) {
+			memset(ctr->values, 0, ctr->num * sizeof(gcov_type));
+			ctr++;
+		}
+#endif /* GCC_VERSION_LOWER */
+}
+
+
+static void cleanup_node_and_path(struct gcov_ftree_node *node);
+
+/* Reset counters on write request. */
+static ssize_t
+write_gcov(struct file *file, const char *buf, size_t count, loff_t *ppos)
+{
+	struct gcov_ftree_node *node;
+	struct gcov_ftree_node *next;
+	struct proc_dir_entry *dir_entry;
+
+	down(&gcov_lock);
+	dir_entry = PDE(file->f_dentry->d_inode);
+	if (dir_entry == proc_vmlinux) {
+		/* Reset all nodes */
+		node = leaf_nodes;
+		while (node) {
+			next = node->next;
+			/* Delete ghosted nodes */
+			if (node->status == status_ghost)
+				cleanup_node_and_path(node);
+			else
+				reset_bb(node->bb);
+			node = next;
+		}
+		/* Nodes may have been deleted - update data */
+		if (gcov_persist)
+			update_vmlinux_data();
+	} else {
+		node = (struct gcov_ftree_node *) dir_entry->data;
+		reset_bb(node->bb);
+	}
+	up(&gcov_lock);
+	return count;
+}
+
+
+/* Return a newly allocated copy of STRING. */
+static inline char *
+strdup(const char *string)
+{
+	char *result;
+
+	result = (char *) kmalloc(strlen(string) + 1, GFP_KERNEL);
+	if (result)
+		strcpy(result, string);
+	return result;
+}
+
+
+/* Allocate a new node and fill in NAME and BB. */
+static struct gcov_ftree_node *
+alloc_node(const char *name, struct bb *bb)
+{
+	struct gcov_ftree_node *node;
+
+	node = (struct gcov_ftree_node *)
+		kmalloc(sizeof(struct gcov_ftree_node), GFP_KERNEL);
+	if (!node)
+		return NULL;
+	memset(node, 0, sizeof(struct gcov_ftree_node));
+	node->fname = strdup(name);
+	if (!node->fname) {
+		kfree(node);
+		return NULL;
+	}
+	node->bb = bb;
+	node->status = status_normal;
+	return node;
+}
+
+
+/* Free memory allocated for BB. */
+static void
+free_bb(struct bb *bb)
+{
+#if GCC_VERSION_LOWER(3,4)
+	kfree(bb);
+#else
+	kfree(bb->functions);
+	kfree(bb);
+#endif /* GCC_VERSION_LOWER */
+}
+
+
+/* Free memory allocated for NODE. */
+static void
+free_node(struct gcov_ftree_node *node)
+{
+	if (node == &tree_root)
+		return;
+	if (node->fname)
+		kfree(node->fname);
+	if (node->status == status_ghost)
+		free_bb(node->bb);
+	kfree(node);
+}
+
+
+/* Remove proc filesystem entries associated with NODE. */
+static void
+delete_from_proc(struct gcov_ftree_node *node)
+{
+	struct proc_dir_entry *parent;
+	int i;
+
+	if (node->parent)
+		parent = node->parent->proc[0];
+	else
+		parent = &proc_root;
+	for (i = 0; i < sizeof(node->proc) / sizeof(node->proc[0]); i++)
+		if (node->proc[i])
+			remove_proc_entry(node->proc[i]->name, parent);
+}
+
+
+/* Release all resources associated with NODE. If NODE is a directory node,
+ * also clean up all children. */
+static void
+cleanup_node(struct gcov_ftree_node *node)
+{
+	struct gcov_ftree_node *curr;
+	struct gcov_ftree_node *next;
+	struct gcov_ftree_node *prev;
+
+	next = node;
+	do {
+		/* Depth first traversal of all children */
+		curr = next;
+		while (curr->files)
+			curr = curr->files;
+		if (curr->sibling)
+			next = curr->sibling;
+		else
+			next = curr->parent;
+		/* Remove from tree */
+		if (curr->parent) {
+			if (curr->parent->files == curr)
+				curr->parent->files = curr->sibling;
+			else {
+				for (prev = curr->parent->files;
+				     prev->sibling != curr;
+				     prev = prev->sibling);
+				prev->sibling = curr->sibling;
+			}
+		}
+		/* Remove from leaf node list if necessary */
+		if (curr->bb) {
+			if (leaf_nodes == curr)
+				leaf_nodes = curr->next;
+			else {
+				for (prev = leaf_nodes;
+				     prev && (prev->next != curr);
+				     prev = prev->next);
+				if (prev)
+					prev->next = curr->next;
+			}
+		}
+		/* Delete node */
+		delete_from_proc(curr);
+		free_node(curr);
+	} while (node != curr);
+}
+
+
+/* Clean up NODE and containing path in case it would be left empty. */
+static void
+cleanup_node_and_path(struct gcov_ftree_node *node)
+{
+	while (node->parent &&
+	       node->parent != &tree_root &&
+	       !node->parent->files->sibling)
+		node = node->parent;
+	cleanup_node(node);
+}
+
+
+/* Create a new directory node named NAME under PARENT. Upon success return
+ * zero and update RESULT to point to the newly created node. Return non-zero
+ * otherwise. */
+static int
+create_dir_node(struct gcov_ftree_node *parent, char *name,
+		struct gcov_ftree_node **result)
+{
+	struct gcov_ftree_node *node;
+
+	/* Initialize new node */
+	node = alloc_node(name, NULL);
+	if (!node)
+		return -ENOMEM;
+	/* Create proc filesystem entry */
+	node->proc[0] = proc_mkdir(name, parent->proc[0]);
+	if (!node->proc[0]) {
+		free_node(node);
+		return -EIO;
+	}
+	/* Insert node into tree */
+	node->parent = parent;
+	node->sibling = parent->files;
+	parent->files = node;
+	*result = node;
+	return 0;
+}
+
+
+static struct file_operations proc_gcov_operations = {
+	read: read_gcov,
+	write: write_gcov,
+	owner: THIS_MODULE
+};
+
+/* Create a new file node named NAME under PARENT. Associate node with BB.
+ * Return zero upon success, non-zero otherwise. */
+static int
+create_file_node(struct gcov_ftree_node *parent, char *name, struct bb *bb)
+{
+	struct gcov_ftree_node *node;
+	char *link_target;
+	char *link_name;
+	int i;
+
+	/* Initialize new node */
+	node = alloc_node(name, bb);
+	if (!node)
+		return -ENOMEM;
+	/* Create proc filesystem entry */
+	node->proc[0] = create_proc_entry(name, S_IWUSR | S_IRUGO,
+					  parent->proc[0]);
+	if (!node->proc[0]) {
+		free_node(node);
+		return -EIO;
+	}
+	node->proc[0]->data = node;
+	node->proc[0]->proc_fops = &proc_gcov_operations;
+	node->proc[0]->size = sizeof_da_file(bb);
+	/* Create symbolic links */
+	if (gcov_link) {
+		/* Note: temp string length is calculated as upper limit */
+		link_target = (char *) kmalloc(strlen(bb->filename) +
+					       strlen(da_ending) +
+					       strlen(gcov_sourcepath),
+					       GFP_KERNEL);
+		if (!link_target) {
+			delete_from_proc(node);
+			free_node(node);
+			return -ENOMEM;
+		}
+		for (i = 0; i < sizeof(endings) / sizeof(endings[0]); i++) {
+			if ((strcmp(endings[i], "c") == 0) &&
+			    (strcmp(gcov_sourcepath, gcov_objectpath) != 0) &&
+			    (strncmp(bb->filename, gcov_objectpath,
+				     objectpath_len) == 0)) {
+				strcpy(link_target, gcov_sourcepath);
+				strcat(link_target,
+				       bb->filename + objectpath_len);
+			} else {
+				strcpy(link_target, bb->filename);
+			}
+			link_target[strlen(link_target) -
+				    strlen(da_ending)] = 0;
+			strcat(link_target, endings[i]);
+			link_name = strrchr(link_target, '/') + 1;
+			node->proc[i + 1] = proc_symlink(link_name,
+							 parent->proc[0],
+							 link_target);
+			if (!node->proc[i + 1]) {
+				kfree(link_target);
+				delete_from_proc(node);
+				free_node(node);
+				return -EIO;
+			}
+		}
+		kfree(link_target);
+	}
+	/* Insert node into tree */
+	node->parent = parent;
+	node->sibling = parent->files;
+	parent->files = node;
+	node->next = leaf_nodes;
+	leaf_nodes = node;
+	return 0;
+}
+
+
+/* Return proc filesystem entry name for FILENAME. */
+static char *
+get_proc_filename(const char *filename)
+{
+	char *result;
+
+	/* Is this file located in the kernel source directory? */
+	if (strncmp(filename, gcov_objectpath, objectpath_len) == 0) {
+		/* Use relative path */
+		result = strdup(filename + objectpath_len + 1);
+	} else {
+		/* Use full path in module subdirectory */
+		result = (char *) kmalloc(strlen(GCOV_PROC_MODULE) +
+					  strlen(filename) + 1, GFP_KERNEL);
+		if (result) {
+			strcpy(result, GCOV_PROC_MODULE);
+			strcat(result, filename);
+		}
+	}
+	return result;
+}
+
+
+/* Create tree node and proc filesystem entry for BB. Create subdirectories as
+ * necessary. Return zero upon success, non-zero otherwise. */
+static int
+create_node(struct bb *bb)
+{
+	struct gcov_ftree_node *parent;
+	struct gcov_ftree_node *node;
+	char *filename;
+	char *curr;
+	char *next;
+	int rc;
+
+	filename = get_proc_filename(bb->filename);
+	if (!filename)
+		return -ENOMEM;
+	/* Recreate directory path in proc filesystem */
+	parent = &tree_root;
+	for (curr = filename; (next = strchr(curr, '/')); curr = next + 1) {
+		/* Skip empty path components */
+		if (curr == next)
+			continue;
+		*next = 0;
+		/* Check whether directory already exists */
+		for (node = parent->files;
+		     node && (strcmp(node->fname, curr) != 0);
+		     node = node->sibling);
+		if (!node) {
+			/* Create directory node */
+			rc = create_dir_node(parent, curr, &node);
+			if (rc) {
+				if (parent != &tree_root)
+					cleanup_node_and_path(parent);
+				kfree(filename);
+				return rc;
+			}
+		}
+		parent = node;
+	}
+	rc = create_file_node(parent, curr, bb);
+	kfree(filename);
+	return rc;
+}
+
+
+/* Return a copy of BB which contains only data relevant to this module. */
+static struct bb *
+clone_bb(struct bb *bb)
+{
+	struct bb *result;
+	size_t len;
+
+#if GCC_VERSION_LOWER(3, 3) 
+	/* Allocate memory */
+	len = sizeof(struct bb) + bb->ncounts * sizeof(gcov_type) +
+	      strlen(bb->filename) + 1;
+	result = (struct bb *) kmalloc(len, GFP_KERNEL);
+	if (!result)
+		return NULL;
+	memset(result, 0, len);
+	/* Copy count data */
+	result->counts = (gcov_type *) (result + 1);
+	result->ncounts = bb->ncounts;
+	memcpy(result->counts, bb->counts, result->ncounts * sizeof(gcov_type));
+	/* Copy filename */
+	result->filename = (const char *) &result->counts[result->ncounts];
+	strcpy((char *) result->filename, bb->filename);
+#elif GCC_VERSION_LOWER(3, 4)
+	unsigned int i;
+	char *name;
+
+	/* Allocate memory */
+	len = sizeof(struct bb) + bb->ncounts * sizeof(gcov_type) +
+	      strlen(bb->filename) + 1 + sizeof(struct bb_function_info);
+	for (i = 0; bb->function_infos[i].arc_count != -1; i++)
+		len += sizeof(struct bb_function_info) +
+		       strlen(bb->function_infos[i].name) + 1;
+	result = (struct bb *) kmalloc(len, GFP_KERNEL);
+	if (!result)
+		return NULL;
+	memset(result, 0, len);
+	/* Copy count data */
+	result->counts = (gcov_type *) (result + 1);
+	result->ncounts = bb->ncounts;
+	memcpy(result->counts, bb->counts, result->ncounts * sizeof(gcov_type));
+	/* Prepare copy of function infos */
+	result->function_infos = (struct bb_function_info *)
+					&result->counts[result->ncounts];
+	/* Copy filename */
+	result->filename = (const char *) &result->function_infos[i + 1];
+	strcpy((char *) result->filename, bb->filename);
+	/* Copy function infos */
+	name = (char *) result->filename + strlen(result->filename) + 1;
+	for (i = 0; bb->function_infos[i].arc_count != -1; i++) {
+		result->function_infos[i].checksum =
+			bb->function_infos[i].checksum;
+		result->function_infos[i].arc_count =
+			bb->function_infos[i].arc_count;
+		strcpy(name, bb->function_infos[i].name);
+		result->function_infos[i].name = name;
+		name += strlen(name) + 1;
+	}
+	result->function_infos[i].arc_count = -1;
+	result->sizeof_bb = bb->sizeof_bb;
+#else
+	unsigned int active;
+	unsigned int i;
+	char *name;
+	struct gcov_fn_info *func;
+
+	/* Allocate memory for struct bb */
+	active = num_counter_active(bb); 
+	len = sizeof(struct bb) +
+	      sizeof(struct gcov_ctr_info) * active +
+	      strlen(bb->filename) + 1;
+	for (i=0; i < active; i++)
+		len += sizeof(gcov_type) * bb->counts[i].num;
+	result = (struct bb *) kmalloc(len, GFP_KERNEL);
+	if (!result)
+		return NULL;
+	memset(result, 0, len);
+	/* Allocate memory for array of struct gcov_fn_info */
+	len = bb->n_functions * get_fn_stride(bb);
+	func = (struct gcov_fn_info *) kmalloc(len, GFP_KERNEL);
+	if (!func) {
+		kfree(result);
+		return NULL;
+	}
+	/* Copy function data */
+	memcpy(func, bb->functions, len);
+	result->functions = func;
+	/* Copy counts */
+	for (i=0; i < active; i++) {
+		result->counts[i].num = bb->counts[i].num;
+		result->counts[i].merge = bb->counts[i].merge;
+		if (i == 0) {
+			result->counts[i].values =
+				(gcov_type *) &result->counts[active];
+		} else {
+			result->counts[i].values =
+				result->counts[i - 1].values +
+				result->counts[i - 1].num;
+		}
+		memcpy(result->counts[i].values, bb->counts[i].values,
+		       sizeof(gcov_type) * result->counts[i].num);
+	}
+	/* Copy rest */
+	result->stamp = bb->stamp;
+	name = (char *) (result->counts[active - 1].values +
+			 result->counts[active - 1].num);
+	strcpy(name, bb->filename);
+	result->filename = name;
+	result->n_functions = bb->n_functions;
+	result->ctr_mask = bb->ctr_mask;
+#endif /* GCC_VERSION_LOWER */
+	return result;
+}
+
+
+/* Return non-zero if BB1 and BB2 are compatible, zero otherwise. */
+static int
+is_compatible(struct bb *bb1, struct bb *bb2)
+{
+#if GCC_VERSION_LOWER(3, 3)
+	return (bb1->ncounts == bb2->ncounts);
+#elif GCC_VERSION_LOWER(3, 4)
+	int i;
+
+	if ((bb1->ncounts != bb2->ncounts) ||
+	    (bb1->sizeof_bb != bb2->sizeof_bb))
+		return 0;
+	for (i = 0; (bb1->function_infos[i].arc_count != -1) &&
+		    (bb2->function_infos[i].arc_count != -1); i++)
+		if (bb1->function_infos[i].checksum !=
+		    bb2->function_infos[i].checksum)
+			return 0;
+	return (bb1->function_infos[i].arc_count == -1) &&
+	       (bb2->function_infos[i].arc_count == -1);
+#else
+	return (bb1->stamp == bb2->stamp);
+#endif /* GCC_VERSION_LOWER */
+}
+
+
+/* Add count data from SOURCE to DEST. */
+static void
+merge_bb(struct bb *dest, struct bb *source)
+{
+#if GCC_VERSION_LOWER(3, 4)
+	long i;
+
+	for (i = 0; i < dest->ncounts; i++)
+		dest->counts[i] += source->counts[i];
+#else
+	unsigned int i;
+	unsigned int j;
+
+	for (i=0; i < num_counter_active(dest); i++)
+		for (j=0; j < dest->counts[i].num; j++)
+			dest->counts[i].values[j] +=
+				source->counts[i].values[j];
+#endif /* GCC_VERSION_LOWER */
+}
+
+
+/* If there is a ghosted node for BB, merge old and current data, set status
+ * to normal and return zero. Return non-zero otherwise. */
+static int
+revive_node(struct bb *bb)
+{
+	struct gcov_ftree_node *node;
+
+	/* Check for a ghosted node */
+	for (node = leaf_nodes; node &&
+	     (strcmp(node->bb->filename, bb->filename) != 0);
+	     node=node->next);
+	if (!node)
+		return -ENOENT;
+	/* Check for compatible data */
+	if (!is_compatible(bb, node->bb)) {
+		printk(KERN_WARNING GCOV_PROC_HEADER "discarding saved data "
+		       "for %s due to incompatibilities\n", bb->filename);
+		cleanup_node_and_path(node);
+		update_vmlinux_data();
+		return -EINVAL;
+	}
+	/* Revive */
+	merge_bb(bb, node->bb);
+	kfree(node->bb);
+	node->bb = bb;
+	node->status = status_normal;
+	return 0;
+}
+
+
+/* Make a copy of the struct bb associated with node and set node status to
+ * ghost. Return zero on success, non-zero otherwise. */
+static int
+ghost_node(struct gcov_ftree_node *node)
+{
+	struct bb *bb;
+
+	/* Ghost node instead of removing it */
+	bb = clone_bb(node->bb);
+	if (!bb) {
+		printk(KERN_ERR GCOV_PROC_HEADER "not enough memory to save "
+		       "data for %s", node->bb->filename);
+		return -ENOMEM;
+	}
+	node->bb = bb;
+	node->status = status_ghost;
+	return 0;
+}
+
+
+/* Callback used to keep track of changes in the bb list. */
+static void
+gcov_proc_callback(enum gcov_cmd cmd, struct bb *bb)
+{
+	struct gcov_ftree_node *node;
+	int rc;
+
+	down(&gcov_lock);
+	switch (cmd) {
+	case gcov_add:
+		if (gcov_persist && (revive_node(bb) == 0))
+			break;
+		/* Insert node */
+		rc = create_node(bb);
+		if (rc) {
+			printk(KERN_ERR GCOV_PROC_HEADER "add failed: could "
+			       "not create node for %s (err=%d)\n",
+			       bb->filename, rc);
+		}
+		update_vmlinux_data();
+		break;
+	case gcov_remove:
+		/* Find node to remove */
+		for (node = leaf_nodes; node && (node->bb != bb);
+		     node=node->next);
+		if (!node)
+			break;
+		if (gcov_persist && (ghost_node(node) == 0))
+			break;
+		/* Remove node and empty path */
+		cleanup_node_and_path(node);
+		update_vmlinux_data();
+		break;
+	}
+	up(&gcov_lock);
+}
+
+
+/* Initialize module. */
+static int __init
+gcov_init_module(void)
+{
+	struct bb *bb;
+	int rc;
+
+	printk(KERN_INFO GCOV_PROC_HEADER "initializing proc module "
+	       "(persist=%d link=%d)\n",
+	       gcov_persist, gcov_link);
+	sourcepath_len = strlen(gcov_sourcepath);
+	objectpath_len = strlen(gcov_objectpath);
+	/* Initialize root node and /proc/gcov entry */
+	tree_root.fname = GCOV_PROC_ROOT;
+	tree_root.proc[0] = proc_mkdir(tree_root.fname, NULL);
+	if (!tree_root.proc[0]) {
+		printk(KERN_ERR GCOV_PROC_HEADER "init failed: could not "
+		       "create root proc filesystem entry\n");
+		return -EIO;
+	}
+	/* Create /proc/gcov/vmlinux entry */
+	proc_vmlinux = create_proc_entry(GCOV_PROC_VMLINUX, S_IWUSR | S_IRUGO,
+					 tree_root.proc[0]);
+	if (!proc_vmlinux) {
+		printk(KERN_ERR GCOV_PROC_HEADER "init failed: could not "
+		       "create proc filesystem entry %s\n", GCOV_PROC_VMLINUX);
+		cleanup_node(&tree_root);
+		return -EIO;
+	}
+	proc_vmlinux->proc_fops = &proc_gcov_operations;
+	/* Initialize /proc/gcov tree */
+	down(&gcov_core_lock);
+	for (bb = bb_head; bb ; bb = bb->next) {
+		rc = create_node(bb);
+		if (rc) {
+			printk(KERN_ERR GCOV_PROC_HEADER "init failed: could "
+			       "not create node for %s (err=%d)\n",
+			       bb->filename, rc);
+			remove_proc_entry(proc_vmlinux->name,
+					  tree_root.proc[0]);
+			cleanup_node(&tree_root);
+			up(&gcov_core_lock);
+			return rc;
+		}
+	}
+	gcov_callback = gcov_proc_callback;
+	update_vmlinux_data();
+	up(&gcov_core_lock);
+	up(&gcov_lock);
+	return 0;
+}
+
+
+/* Clean up module data. */
+static void __exit
+gcov_cleanup_module(void)
+{
+	down(&gcov_lock);
+	gcov_callback = NULL;
+	remove_proc_entry(proc_vmlinux->name, tree_root.proc[0]);
+	cleanup_node(&tree_root);
+	printk(KERN_INFO GCOV_PROC_HEADER "proc module is now unloaded\n");
+}
+
+
+module_init(gcov_init_module);
+module_exit(gcov_cleanup_module);
diff -Naurp linux-2.4/include/linux/gcov.h linux-2.4-gcov/include/linux/gcov.h
--- linux-2.4/include/linux/gcov.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4-gcov/include/linux/gcov.h	2004-08-12 17:07:19.320312116 +0200
@@ -0,0 +1,184 @@
+/*
+ * include/linux/gcov.h
+ *
+ * Type declarations and macros used by GCOV kernel profiling.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (c) International Business Machines Corp., 2002-2003
+ *
+ * Author: Hubertus Franke <frankeh@us.ibm.com>
+ *         Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
+ */
+
+#ifndef GCOV_H
+#define GCOV_H GCOV_H
+
+#include <linux/module.h>
+#include <asm/semaphore.h>
+#include <asm/types.h>
+
+#define GCC_VERSION_LOWER(major, minor) ((__GNUC__ < major) || \
+					 (__GNUC__ == major) && \
+					 (__GNUC_MINOR__ < minor))
+
+#if GCC_VERSION_LOWER(3, 1)
+/*
+ * Profiling types for GCC prior to version 3.1
+ */
+
+typedef long gcov_type;
+
+/* Same as gcc/libgcc2.c */
+struct bb
+{
+	long zero_word;
+	const char *filename;
+	long *counts;
+	long ncounts;
+	struct bb *next;
+	const unsigned long *addresses;
+	long nwords;
+	const char **functions;
+	const long *line_nums;
+	const char **filenames;
+	char *flags;
+};
+
+#elif GCC_VERSION_LOWER(3, 3)
+/*
+ * Profiling types for GCC 3.1 to 3.2
+ */
+
+#if BITS_PER_LONG >= 64
+typedef long gcov_type;
+#else
+typedef long long gcov_type;
+#endif
+
+/* Same as gcc/libgcc2.c */
+struct bb
+{
+	long zero_word;
+	const char *filename;
+	gcov_type *counts;
+	long ncounts;
+	struct bb *next;
+	const unsigned long *addresses;
+	long nwords;
+	const char **functions;
+	const long *line_nums;
+	const char **filenames;
+	char *flags;
+};
+
+#elif GCC_VERSION_LOWER(3, 4)
+/*
+ * Profiling types for GCC 3.3
+ */
+
+typedef long long gcov_type;
+
+/* Same as gcc/libgcc2.c */
+struct bb_function_info
+{
+	long checksum;
+	int arc_count;
+	const char *name;
+};
+
+struct bb
+{
+	long zero_word;
+	const char *filename;
+	gcov_type *counts;
+	long ncounts;
+	struct bb *next;
+	long sizeof_bb;
+	struct bb_function_info *function_infos;
+};
+
+#else
+/*
+ * Profiling types for GCC 3.4 and above (see gcc-3.4/gcc/gcov-io.h)
+ */
+
+#define GCOV_COUNTERS		5
+#define GCOV_DATA_MAGIC		((gcov_unsigned_t) 0x67636461)
+#define GCOV_TAG_FUNCTION	((gcov_unsigned_t) 0x01000000)
+#define GCOV_TAG_COUNTER_BASE	((gcov_unsigned_t) 0x01a10000)
+#define GCOV_TAG_FOR_COUNTER(COUNT)					\
+	(GCOV_TAG_COUNTER_BASE + ((gcov_unsigned_t) (COUNT) << 17))
+
+#if BITS_PER_LONG >= 64
+typedef long gcov_type;
+#else
+typedef long long gcov_type;
+#endif
+
+typedef unsigned int gcov_unsigned_t;
+typedef unsigned int gcov_position_t;
+
+typedef void (*gcov_merge_fn) (gcov_type *, gcov_unsigned_t);
+
+struct gcov_fn_info
+{
+	gcov_unsigned_t ident;
+	gcov_unsigned_t checksum;
+	unsigned int n_ctrs[0];			/* Note: the number of bits
+						 * set in bb->ctr_mask decides
+						 * how big this array is. */
+};
+
+struct gcov_ctr_info
+{
+	gcov_unsigned_t num;
+	gcov_type *values;
+	gcov_merge_fn merge;
+};
+
+struct bb /* should be 'struct gcov_info' but we're sticking with the old name
+	   * so we can reuse some of our pre-3.4 functions */
+{
+	gcov_unsigned_t version;
+	struct bb *next;
+	gcov_unsigned_t stamp;
+	const char *filename;
+	unsigned int n_functions;
+	const struct gcov_fn_info *functions;
+	unsigned int ctr_mask;
+	struct gcov_ctr_info counts[0];		/* Note: the number of bits
+						 * set in ctr_mask decides
+						 * how big this array is. */
+};
+
+extern gcov_unsigned_t gcov_version;
+#endif /* GCC_VERSION */
+
+enum gcov_cmd {
+	gcov_add,
+	gcov_remove
+};
+
+extern struct bb *bb_head;
+extern const char *gcov_sourcepath;
+extern const char *gcov_objectpath;
+extern struct semaphore gcov_core_lock;
+
+extern void do_global_ctors(const char *, const char *, struct module *);
+extern void (*gcov_callback)(enum gcov_cmd, struct bb *);
+extern void remove_bb_link(struct module *);
+
+#endif /* GCOV_H */
diff -Naurp linux-2.4/include/linux/module.h linux-2.4-gcov/include/linux/module.h
--- linux-2.4/include/linux/module.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-2.4-gcov/include/linux/module.h	2004-08-12 17:07:16.490312116 +0200
@@ -90,6 +90,8 @@ struct module
 	const char *archdata_start;	/* arch specific data for module */
 	const char *archdata_end;
 	const char *kernel_data;	/* Reserved for kernel internal use */
+	const char *ctors_start;	/* Pointer to start of .ctors-section */
+	const char *ctors_end;		/* Pointer to end of .ctors-section */
 };
 
 struct module_info
diff -Naurp linux-2.4/kernel/module.c linux-2.4-gcov/kernel/module.c
--- linux-2.4/kernel/module.c	2003-08-25 13:44:44.000000000 +0200
+++ linux-2.4-gcov/kernel/module.c	2004-08-12 17:07:16.490312116 +0200
@@ -10,6 +10,7 @@
 #include <linux/slab.h>
 #include <linux/kmod.h>
 #include <linux/seq_file.h>
+#include <linux/gcov.h>
 
 /*
  * Originally by Anonymous (as far as I know...)
@@ -559,6 +560,17 @@ sys_init_module(const char *name_user, s
 
 	/* Initialize the module.  */
 	atomic_set(&mod->uc.usecount,1);
+
+#ifdef CONFIG_GCOV_PROFILE
+	/* Register with gcov core. */
+	if (mod_member_present(mod, ctors_start) &&
+	    mod_member_present(mod, ctors_end) &&
+	    mod->ctors_start &&
+	    mod->ctors_end) {
+		do_global_ctors(mod->ctors_start, mod->ctors_end, mod);
+	}
+#endif
+
 	mod->flags |= MOD_INITIALIZING;
 	if (mod->init && (error = mod->init()) != 0) {
 		atomic_set(&mod->uc.usecount,0);
@@ -1055,6 +1067,14 @@ free_module(struct module *mod, int tag_
 		mod->flags &= ~MOD_RUNNING;
 	}
 
+#ifdef CONFIG_GCOV_PROFILE
+	/* Unregister from gcov core. */
+	if (mod_member_present(mod, ctors_start) &&
+	    mod_member_present(mod, ctors_end)) {
+		remove_bb_link(mod);
+	}
+#endif
+
 	/* Remove the module from the dependency lists.  */
 
 	for (i = 0, dep = mod->deps; i < mod->ndeps; ++i, ++dep) {
